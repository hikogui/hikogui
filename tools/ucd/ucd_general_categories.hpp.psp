// This file was generated by generate_unicode_data.py

#pragma once

#include "../utility/module.hpp"
#include <cstdint>
#include <optional>

// Windows.h defines small as a macro.
#ifdef small
#undef small
#endif

namespace hi {
inline namespace v1 {
namespace detail {

constexpr auto ucd_general_categories_chunk_size = $chunk_size$_uz;
constexpr auto ucd_general_categories_index_width = $index_width$_uz;
constexpr auto ucd_general_categories_indices_size = $indices_size$_uz;
constexpr auto ucd_general_category_width = $general_category_width$_uz;

static_assert(std::has_single_bit(ucd_general_categories_chunk_size));

constexpr uint8_t ucd_general_categories_indices_bytes[$len(indices_bytes)$] = {\
$for i, x in enumerate(indices_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};

constexpr uint8_t ucd_general_categories_bytes[$len(general_categories_bytes)$] = {\
$for i, x in enumerate(general_categories_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};


} // namespace detail

enum class unicode_general_category : uint8_t {
    Lu = 0,
    Ll = 1,
    Lt = 2,
    Lm = 3,
    Lo = 4,
    Mn = 5,
    Mc = 6,
    Me = 7,
    Nd = 8,
    Nl = 9,
    No = 10,
    Pc = 11,
    Pd = 12,
    Ps = 13,
    Pe = 14,
    Pi = 15,
    Pf = 16,
    Po = 17,
    Sm = 18,
    Sc = 19,
    Sk = 20,
    So = 21,
    Zs = 22,
    Zl = 23,
    Zp = 24,
    Cc = 25,
    Cf = 26,
    Cs = 27,
    Co = 28,
    Cn = 29
};

[[nodiscard]] constexpr bool is_LC(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs >= Lu and rhs <= Lt;
}

[[nodiscard]] constexpr bool is_L(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs >= Lu and rhs <= Lo;
}

[[nodiscard]] constexpr bool is_M(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs >= Mn and rhs <= Me;
}

[[nodiscard]] constexpr bool is_Mn_or_Mc(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs == Mn or rhs == Mc;
}

[[nodiscard]] constexpr bool is_N(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs >= Nd and rhs <= No;
}

[[nodiscard]] constexpr bool is_P(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs >= Pc and rhs <= Po;
}

[[nodiscard]] constexpr bool is_S(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs >= Sm and rhs <= So;
}

[[nodiscard]] constexpr bool is_Z(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs >= Zs and rhs <= Zp;
}

[[nodiscard]] constexpr bool is_Zp_or_Zl(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs == Zp or rhs == Zl;
}

[[nodiscard]] constexpr bool is_C(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs >= Cc and rhs <= Cn;
}

[[nodiscard]] constexpr bool is_visible(unicode_general_category const &rhs) noexcept
{
    using enum unicode_general_category;
    return rhs < Zs or rhs == Co;
}

[[nodiscard]] constexpr bool is_noncharacter(char32_t rhs) noexcept
{
    hilet rhs_ = char_cast<uint32_t>(rhs);
    return rhs_ >= 0x11'0000 or (rhs_ & 0xfffe) == 0xfffe or (rhs >= 0xfdd0 and rhs <= 0xfdef);
}

[[nodiscard]] constexpr unicode_general_category ucd_get_general_category(char32_t code_point) noexcept
{
    constexpr auto max_code_point_hi = detail::ucd_general_categories_indices_size - 1;

    auto code_point_hi = code_point / detail::ucd_general_categories_chunk_size;
    hilet code_point_lo = code_point % detail::ucd_general_categories_chunk_size;

    if (code_point_hi > max_code_point_hi) {
        code_point_hi = max_code_point_hi;
    }

    hilet chunk_index = load_bits_be<detail::ucd_general_categories_index_width>(
        detail::ucd_general_categories_indices_bytes,
        code_point_hi * detail::ucd_general_categories_index_width);

    // Add back in the lower-bits of the code-point.
    hilet index = (chunk_index * detail::ucd_general_categories_chunk_size) + code_point_lo;

    // Get the canonical combining class from the table.
    hilet value = load_bits_be<detail::ucd_general_category_width>(
        detail::ucd_general_categories_bytes, index * detail::ucd_general_category_width);

    return static_cast<unicode_general_category>(value);
}

}} // namespace hi::v1

