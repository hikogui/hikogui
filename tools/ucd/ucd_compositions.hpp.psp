// This file was generated by generate_unicode_data.py

#pragma once

#include "../utility/utility.hpp"
#include <cstdint>
#include <optional>
#include <bit>
#include <string_view>
#include <string>

// Windows.h defines small as a macro.
#ifdef small
#undef small
#endif

hi_export_module(hikogui.unicode.ucd_compositions);

hi_export namespace hi {
inline namespace v1 {
namespace detail {

constexpr auto ucd_compositions_chunk_size = $chunk_size$_uz;
constexpr auto ucd_compositions_code_point_width = $code_point_width$_uz;
constexpr auto ucd_compositions_indices_size = $indices_size$_uz;
constexpr auto ucd_compositions_index_width = $index_width$_uz;
constexpr auto ucd_composition_width = $composition_width$_uz;

static_assert(std::has_single_bit(ucd_compositions_chunk_size));

constexpr uint8_t ucd_compositions_indices_bytes[$len(indices_bytes)$] = {\
$for i, x in enumerate(indices_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};

constexpr uint8_t ucd_compositions_bytes[$len(compositions_bytes)$] = {\
$for i, x in enumerate(compositions_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};

constexpr uint8_t ucd_composition_code_points_bytes[$len(code_points_bytes)$] = {\
$for i, x in enumerate(code_points_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};

} // namespace detail


/** Get the composition info of two code-points.
 *
 * @param cp1 The first code-point
 * @param cp2 The second code-point
 * @return The code-point forming the composition of the two given code-points,
 *         or std::nullopt if the two code-point don't composit.
 */
[[nodiscard]] constexpr std::optional<char32_t> ucd_get_composition(char32_t cp1, char32_t cp2) noexcept
{
    constexpr auto max_code_point_hi = detail::ucd_compositions_indices_size - 1;

    auto code_point_hi = cp1 / detail::ucd_compositions_chunk_size;
    auto const code_point_lo = cp1 % detail::ucd_compositions_chunk_size;

    if (code_point_hi > max_code_point_hi) {
        code_point_hi = max_code_point_hi;
    }

    // The index in the chunk-index table based on the upper-bits of the code-point.
    auto const chunk_index = load_bits_be<detail::ucd_compositions_index_width>(
        detail::ucd_compositions_indices_bytes,
        code_point_hi * detail::ucd_compositions_index_width);

    // Add back in the lower-bits of the code-point.
    auto const index = (chunk_index * detail::ucd_compositions_chunk_size) + code_point_lo;

    // Get the composition value from the composition table by index.
    auto const value = load_bits_be<detail::ucd_composition_width>(
        detail::ucd_compositions_bytes, index * detail::ucd_composition_width);

    constexpr auto cp_size_width = $cp_size_width$;
    constexpr auto cp_size_mask = (1_uz << cp_size_width) - 1;
    auto const cp_size = value & cp_size_mask;
    if (cp_size == 0) {
        return std::nullopt;
    }

    auto const cp_index = value >> cp_size_width;

    auto offset = cp_index * 2_uz * detail::ucd_compositions_code_point_width;
    for (auto i = 0_uz; i != cp_size; ++i, offset += detail::ucd_compositions_code_point_width) {
        auto const second_cp = load_bits_be<detail::ucd_compositions_code_point_width>(
            detail::ucd_composition_code_points_bytes, offset);

        if (second_cp == cp2) {
            offset += cp_size * detail::ucd_compositions_code_point_width;

            auto const result_cp = load_bits_be<detail::ucd_compositions_code_point_width>(
                detail::ucd_composition_code_points_bytes, offset);

            return char_cast<char32_t>(result_cp);

        } else if (second_cp > cp2) {
            // Early out, `load_bits_be` is kinda expensive and on average (mean)
            // this list is about 15 entries in size.
            return std::nullopt;
        }
    }

    return std::nullopt;
}

}} // namespace hi::v1

