// This file was generated by generate_unicode_data.py

#pragma once

#include "../utility/module.hpp"
#include <cstdint>
#include <optional>

// Windows.h defines small as a macro.
#ifdef small
#undef small
#endif

namespace hi {
inline namespace v1 {
namespace detail {

constexpr auto ucd_word_break_properties_chunk_size = $chunk_size$_uz;
constexpr auto ucd_word_break_properties_index_width = $index_width$_uz;
constexpr auto ucd_word_break_properties_indices_size = $indices_size$_uz;
constexpr auto ucd_word_break_property_width = $word_break_property_width$_uz;

static_assert(std::has_single_bit(ucd_word_break_properties_chunk_size));

constexpr uint8_t ucd_word_break_properties_indices_bytes[$len(indices_bytes)$] = {\
$for i, x in enumerate(indices_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};

constexpr uint8_t ucd_word_break_properties_bytes[$len(word_break_properties_bytes)$] = {\
$for i, x in enumerate(word_break_properties_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};


} // namespace detail

enum class unicode_word_break_property : uint8_t {
    Other = 0,
    CR = 1,
    LF = 2,
    Newline = 3,
    Extend = 4,
    ZWJ = 5,
    Regional_Indicator = 6,
    Format = 7,
    Katakana = 8,
    Hebrew_Letter = 9,
    ALetter = 10,
    Single_Quote = 11,
    Double_Quote = 12,
    MidNumLet = 13,
    MidLetter = 14,
    MidNum = 15,
    Numeric = 16,
    ExtendNumLet = 17,
    WSegSpace = 18
};

[[nodiscard]] constexpr unicode_word_break_property ucd_get_word_break_property(char32_t code_point) noexcept
{
    constexpr auto max_code_point_hi = detail::ucd_word_break_properties_indices_size - 1;

    auto code_point_hi = code_point / detail::ucd_word_break_properties_chunk_size;
    hilet code_point_lo = code_point % detail::ucd_word_break_properties_chunk_size;

    if (code_point_hi > max_code_point_hi) {
        code_point_hi = max_code_point_hi;
    }

    hilet chunk_index = load_bits_be<detail::ucd_word_break_properties_index_width>(
        detail::ucd_word_break_properties_indices_bytes,
        code_point_hi * detail::ucd_word_break_properties_index_width);

    // Add back in the lower-bits of the code-point.
    hilet index = (chunk_index * detail::ucd_word_break_properties_chunk_size) + code_point_lo;

    // Get the canonical combining class from the table.
    hilet value = load_bits_be<detail::ucd_word_break_property_width>(
        detail::ucd_word_break_properties_bytes, index * detail::ucd_word_break_property_width);

    return static_cast<unicode_word_break_property>(value);
}

}} // namespace hi::v1

